<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Neon Tetris</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="game-wrapper">
        <div class="header-bar">
            <a href="index.html" class="neon-btn">ðŸ”™ Menu</a>
            <div id="score" style="font-family: 'Orbitron'; font-size: 1.5rem;">Score: 0</div>
            <button class="neon-btn secondary" onclick="resetGame()">Restart</button>
        </div>
        <canvas id="tetrisCanvas" width="300" height="600"></canvas>
        <p style="color: #888; margin-top: 10px;">PhÃ­m mÅ©i tÃªn Ä‘á»ƒ di chuyá»ƒn vÃ  xoay</p>
    </div>

    <script>
        const canvas = document.getElementById('tetrisCanvas');
        const ctx = canvas.getContext('2d');
        const ROW = 20, COL = 10, SQ = 30;
        const VACANT = "#111"; // MÃ u Ã´ trá»‘ng

        // Váº½ Ã´ vuÃ´ng
        function drawSquare(x, y, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x*SQ, y*SQ, SQ, SQ);
            ctx.strokeStyle = "#050505";
            ctx.strokeRect(x*SQ, y*SQ, SQ, SQ);
            
            // Hiá»‡u á»©ng Neon
            if(color !== VACANT) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                ctx.strokeRect(x*SQ, y*SQ, SQ, SQ);
            } else {
                ctx.shadowBlur = 0;
            }
        }

        // Táº¡o báº£ng
        let board = [];
        for(let r=0; r<ROW; r++){
            board[r] = [];
            for(let c=0; c<COL; c++) board[r][c] = VACANT;
        }

        function drawBoard(){
            for(let r=0; r<ROW; r++)
                for(let c=0; c<COL; c++) drawSquare(c, r, board[r][c]);
        }
        drawBoard();

        // HÃ¬nh dáº¡ng cÃ¡c khá»‘i (Tetrominoes)
        const PIECES = [
            [Z,"#f00"], [S,"#0f0"], [T,"#ff0"], [O,"#00f"], [L,"#f0f"], [I,"#0ff"], [J,"#fa0"]
        ];

        // Äá»‹nh nghÄ©a cÃ¡c khá»‘i (Z, S, T, O, L, I, J) - RÃºt gá»n
        var Z = [[[1,1,0],[0,1,1],[0,0,0]], [[0,0,1],[0,1,1],[0,1,0]], [[0,0,0],[1,1,0],[0,1,1]], [[0,1,0],[1,1,0],[1,0,0]]];
        var S = [[[0,1,1],[1,1,0],[0,0,0]], [[0,1,0],[0,1,1],[0,0,1]], [[0,0,0],[0,1,1],[1,1,0]], [[1,0,0],[1,1,0],[0,1,0]]];
        var T = [[[0,1,0],[1,1,1],[0,0,0]], [[0,1,0],[0,1,1],[0,1,0]], [[0,0,0],[1,1,1],[0,1,0]], [[0,1,0],[1,1,0],[0,1,0]]];
        var O = [[[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]];
        var L = [[[0,0,1],[1,1,1],[0,0,0]], [[0,1,0],[0,1,0],[0,1,1]], [[0,0,0],[1,1,1],[1,0,0]], [[1,1,0],[0,1,0],[0,1,0]]];
        var I = [[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]], [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]], [[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]]];
        var J = [[[1,0,0],[1,1,1],[0,0,0]], [[0,1,1],[0,1,0],[0,1,0]], [[0,0,0],[1,1,1],[0,0,1]], [[0,1,0],[0,1,0],[1,1,0]]];

        // Fix biáº¿n reference
        PIECES[0][0] = Z; PIECES[1][0] = S; PIECES[2][0] = T; PIECES[3][0] = O; 
        PIECES[4][0] = L; PIECES[5][0] = I; PIECES[6][0] = J;

        let score = 0;
        
        class Piece {
            constructor(tetromino, color){
                this.tetromino = tetromino;
                this.color = color;
                this.tetrominoN = 0; // gÃ³c xoay
                this.activeTetromino = this.tetromino[this.tetrominoN];
                this.x = 3;
                this.y = -2;
            }
            fill(color){
                for(let r=0; r<this.activeTetromino.length; r++){
                    for(let c=0; c<this.activeTetromino.length; c++){
                        if(this.activeTetromino[r][c]) drawSquare(this.x + c, this.y + r, color);
                    }
                }
            }
            draw(){ this.fill(this.color); }
            unDraw(){ this.fill(VACANT); }
            moveDown(){
                if(!this.collision(0,1,this.activeTetromino)){
                    this.unDraw(); this.y++; this.draw();
                } else {
                    this.lock();
                    p = randomPiece();
                }
            }
            moveRight(){ if(!this.collision(1,0,this.activeTetromino)){ this.unDraw(); this.x++; this.draw(); } }
            moveLeft(){ if(!this.collision(-1,0,this.activeTetromino)){ this.unDraw(); this.x--; this.draw(); } }
            rotate(){
                let nextPattern = this.tetromino[(this.tetrominoN + 1) % this.tetromino.length];
                let kick = 0;
                if(this.collision(0,0,nextPattern)){
                    if(this.x > COL/2) kick = -1; else kick = 1; // Wall kick
                }
                if(!this.collision(kick,0,nextPattern)){
                    this.unDraw();
                    this.x += kick;
                    this.tetrominoN = (this.tetrominoN + 1) % this.tetromino.length;
                    this.activeTetromino = this.tetromino[this.tetrominoN];
                    this.draw();
                }
            }
            collision(x,y,piece){
                for(let r=0; r<piece.length; r++){
                    for(let c=0; c<piece.length; c++){
                        if(!piece[r][c]) continue;
                        let newX = this.x + c + x;
                        let newY = this.y + r + y;
                        if(newX < 0 || newX >= COL || newY >= ROW) return true;
                        if(newY < 0) continue;
                        if(board[newY][newX] != VACANT) return true;
                    }
                }
                return false;
            }
            lock(){
                for(let r=0; r<this.activeTetromino.length; r++){
                    for(let c=0; c<this.activeTetromino.length; c++){
                        if(!this.activeTetromino[r][c]) continue;
                        if(this.y + r < 0) {
                            alert("Game Over");
                            resetGame();
                            return;
                        }
                        board[this.y+r][this.x+c] = this.color;
                    }
                }
                // XÃ³a hÃ ng
                for(let r=0; r<ROW; r++){
                    let isRowFull = true;
                    for(let c=0; c<COL; c++) isRowFull = isRowFull && (board[r][c] != VACANT);
                    if(isRowFull){
                        for(let y=r; y>1; y--){
                            for(let c=0; c<COL; c++) board[y][c] = board[y-1][c];
                        }
                        for(let c=0; c<COL; c++) board[0][c] = VACANT;
                        score += 10;
                        document.getElementById("score").innerHTML = "Score: " + score;
                    }
                }
                drawBoard();
            }
        }

        function randomPiece(){
            let r = Math.floor(Math.random() * PIECES.length);
            return new Piece(PIECES[r][0], PIECES[r][1]);
        }

        let p = randomPiece();
        let dropStart = Date.now();
        function drop(){
            let now = Date.now();
            let delta = now - dropStart;
            if(delta > 1000){ // Tá»‘c Ä‘á»™ rÆ¡i 1s
                p.moveDown();
                dropStart = Date.now();
            }
            if(!isGameOver) requestAnimationFrame(drop);
        }

        let isGameOver = false;
        document.addEventListener("keydown", CONTROL);
        function CONTROL(event){
            if(event.keyCode == 37) p.moveLeft();
            else if(event.keyCode == 38) p.rotate();
            else if(event.keyCode == 39) p.moveRight();
            else if(event.keyCode == 40) p.moveDown();
        }

        function resetGame() {
            for(let r=0; r<ROW; r++) for(let c=0; c<COL; c++) board[r][c] = VACANT;
            drawBoard();
            score = 0; document.getElementById("score").innerHTML = "Score: 0";
            p = randomPiece();
        }

        drop();
    </script>
</body>
</html>

